const request = require("supertest");
const server = require("./vulnerable-app");

describe("Next.js Middleware Security Tests", () => {
  let app;

  beforeAll(() => {
    // Create a supertest instance
    app = request(server);
  });

  afterAll((done) => {
    server.close(done);
  });

  // Test 1: Verify the endpoint is actually protected
  test("Protected endpoint should require authentication", async () => {
    const response = await app.get("/admin");

    expect(response.status).toBe(401);
    expect(response.body).toHaveProperty("error", "Unauthorized");
  });

  // Test 2: Check if middleware can be bypassed with known payloads
  describe("Middleware bypass vulnerability tests", () => {
    const bypassPayloads = [
      "middleware",
      "pages/_middleware",
      "middleware:middleware:middleware:middleware:middleware",
      "src/middleware:src/middleware:src/middleware:src/middleware:src/middleware",
    ];

    test.each(bypassPayloads)(
      "Protected endpoint should not be accessible with x-middleware-subrequest: %s",
      async (payload) => {
        const response = await app
          .get("/admin")
          .set("x-middleware-subrequest", payload);

        // This test will fail if the vulnerability exists
        // In a secure app, this would pass because response would be 401
        expect(response.status).toBe(401);
        expect(response.body).toHaveProperty("error", "Unauthorized");
      }
    );
  });

  // Test 3: Verify that authenticated requests still work properly
  test("Authenticated requests should be allowed", async () => {
    const response = await app
      .get("/admin")
      .set("Authorization", "Bearer valid-token");

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty(
      "message",
      "Admin area - sensitive content"
    );
  });
});
